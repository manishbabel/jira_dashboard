(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
        if (typeof tnt === "undefined") {
            module.exports = tnt = {};
        }
        tnt.tooltip = require("./index.js");

    },{"./index.js":2}],2:[function(require,module,exports){
        module.exports = tooltip = require("./src/tooltip.js");

    },{"./src/tooltip.js":5}],3:[function(require,module,exports){
        module.exports = require("./src/api.js");

    },{"./src/api.js":4}],4:[function(require,module,exports){
        var api = function (who) {

            var _methods = function () {
                var m = [];

                m.add_batch = function (obj) {
                    m.unshift(obj);
                };

                m.update = function (method, value) {
                    for (var i=0; i<m.length; i++) {
                        for (var p in m[i]) {
                            if (p === method) {
                                m[i][p] = value;
                                return true;
                            }
                        }
                    }
                    return false;
                };

                m.add = function (method, value) {
                    if (m.update (method, value) ) {
                    } else {
                        var reg = {};
                        reg[method] = value;
                        m.add_batch (reg);
                    }
                };

                m.get = function (method) {
                    for (var i=0; i<m.length; i++) {
                        for (var p in m[i]) {
                            if (p === method) {
                                return m[i][p];
                            }
                        }
                    }
                };

                return m;
            };

            var methods    = _methods();
            var api = function () {};

            api.check = function (method, check, msg) {
                if (method instanceof Array) {
                    for (var i=0; i<method.length; i++) {
                        api.check(method[i], check, msg);
                    }
                    return;
                }

                if (typeof (method) === 'function') {
                    method.check(check, msg);
                } else {
                    who[method].check(check, msg);
                }
                return api;
            };

            api.transform = function (method, cbak) {
                if (method instanceof Array) {
                    for (var i=0; i<method.length; i++) {
                        api.transform (method[i], cbak);
                    }
                    return;
                }

                if (typeof (method) === 'function') {
                    method.transform (cbak);
                } else {
                    who[method].transform(cbak);
                }
                return api;
            };

            var attach_method = function (method, opts) {
                var checks = [];
                var transforms = [];

                var getter = opts.on_getter || function () {
                    return methods.get(method);
                };

                var setter = opts.on_setter || function (x) {
                    for (var i=0; i<transforms.length; i++) {
                        x = transforms[i](x);
                    }

                    for (var j=0; j<checks.length; j++) {
                        if (!checks[j].check(x)) {
                            var msg = checks[j].msg ||
                                ("Value " + x + " doesn't seem to be valid for this method");
                            throw (msg);
                        }
                    }
                    methods.add(method, x);
                };

                var new_method = function (new_val) {
                    if (!arguments.length) {
                        return getter();
                    }
                    setter(new_val);
                    return who; // Return this?
                };
                new_method.check = function (cbak, msg) {
                    if (!arguments.length) {
                        return checks;
                    }
                    checks.push ({check : cbak,
                        msg   : msg});
                    return this;
                };
                new_method.transform = function (cbak) {
                    if (!arguments.length) {
                        return transforms;
                    }
                    transforms.push(cbak);
                    return this;
                };

                who[method] = new_method;
            };

            var getset = function (param, opts) {
                if (typeof (param) === 'object') {
                    methods.add_batch (param);
                    for (var p in param) {
                        attach_method (p, opts);
                    }
                } else {
                    methods.add (param, opts.default_value);
                    attach_method (param, opts);
                }
            };

            api.getset = function (param, def) {
                getset(param, {default_value : def});

                return api;
            };

            api.get = function (param, def) {
                var on_setter = function () {
                    throw ("Method defined only as a getter (you are trying to use it as a setter");
                };

                getset(param, {default_value : def,
                    on_setter : on_setter}
                );

                return api;
            };

            api.set = function (param, def) {
                var on_getter = function () {
                    throw ("Method defined only as a setter (you are trying to use it as a getter");
                };

                getset(param, {default_value : def,
                    on_getter : on_getter}
                );

                return api;
            };

            api.method = function (name, cbak) {
                if (typeof (name) === 'object') {
                    for (var p in name) {
                        who[p] = name[p];
                    }
                } else {
                    who[name] = cbak;
                }
                return api;
            };

            return api;

        };

        module.exports = exports = api;
    },{}],5:[function(require,module,exports){
        var apijs = require("tnt.api");

        var tooltip = function () {
            "use strict";

            var drag = d3.drag();
            var tooltip_div;

            var conf = {
                container: undefined,
                position : "right",
                allow_drag : true,
                show_closer : false,
                fill : function () { throw "fill is not defined in the base object"; },
                width : 180,
                id : 1
            };

            var t = function (data, event) {
                drag
                    .subject(function(){
                        return {
                            x : parseInt(d3.select(this).style("left")),
                            y : parseInt(d3.select(this).style("top"))
                        };
                    })
                    .on("drag", function() {
                        if (conf.allow_drag) {
                            d3.select(this)
                                .style("left", d3.event.x + "px")
                                .style("top", d3.event.y + "px");
                        }
                    });

                // TODO: Why do we need the div element?
                // It looks like if we anchor the tooltip in the "body"
                // The tooltip is not located in the right place (appears at the bottom)
                // See clients/tooltips_test.html for an example
                var containerElem = conf.container;
                if (!containerElem) {
                    containerElem = selectAncestor(this, "div");
                    if (containerElem === undefined) {
                        // We require a div element at some point to anchor the tooltip
                        return;
                    }
                }

                tooltip_div = d3.select(containerElem)
                    .append("div")
                    .attr("class", "tnt_tooltip")
                    .classed("tnt_tooltip_active", true)  // TODO: Is this needed/used???
                    .call(drag);

                // prev tooltips with the same header
                d3.select("#tnt_tooltip_" + conf.id).remove();

                if ((d3.event === null) && (event)) {
                    d3.event = event;
                }
                var d3mouse = d3.mouse(containerElem);
                d3.event = null;

                var xoffset = -10;
                var yoffset = 10;
                if (conf.position === "left") {
                    xoffset = conf.width;
                }

                tooltip_div.attr("id", "tnt_tooltip_" + conf.id);

                // We place the tooltip
                tooltip_div
                    .style("left", (d3mouse[0] - xoffset) + "px")
                    .style("top", (d3mouse[1] - yoffset) + "px");

                // Close
                if (conf.show_closer) {
                    tooltip_div
                        .append("div")
                        .attr("class", "tnt_tooltip_closer")
                        .on ("click", function () {
                            t.close();
                        });
                }

                conf.fill.call(tooltip_div.node(), data);

                // return this here?
                return t;
            };

            // gets the first ancestor of elem having tagname "type"
            // example : var mydiv = selectAncestor(myelem, "div");
            function selectAncestor (elem, type) {
                type = type.toLowerCase();
                if (elem.parentNode === null) {
                    console.log("No more parents");
                    return undefined;
                }
                var tagName = elem.parentNode.tagName;

                if ((tagName !== undefined) && (tagName.toLowerCase() === type)) {
                    return elem.parentNode;
                } else {
                    return selectAncestor (elem.parentNode, type);
                }
            }

            var api = apijs(t)
                .getset(conf);

            api.check('position', function (val) {
                return (val === 'left') || (val === 'right');
            }, "Only 'left' or 'right' values are allowed for position");

            api.method('close', function () {
                if (tooltip_div) {
                    tooltip_div.remove();
                }
            });

            return t;
        };

        tooltip.list = function () {
            // list tooltip is based on general tooltips
            var t = tooltip();
            var width = 180;

            t.fill (function (obj) {
                var tooltip_div = d3.select(this);
                var obj_info_list = tooltip_div
                    .append("table")
                    .attr("class", "tnt_zmenu")
                    .attr("border", "solid")
                    .style("width", t.width() + "px");

                // Tooltip header
                if (obj.header) {
                    obj_info_list
                        .append("tr")
                        .attr("class", "tnt_zmenu_header")
                        .append("th")
                        .text(obj.header);
                }

                // Tooltip rows
                var table_rows = obj_info_list.selectAll(".tnt_zmenu_row")
                    .data(obj.rows)
                    .enter()
                    .append("tr")
                    .attr("class", "tnt_zmenu_row");

                table_rows
                    .append("td")
                    .style("text-align", "center")
                    .html(function(d,i) {
                        return obj.rows[i].value;
                    })
                    .each(function (d) {
                        if (d.link === undefined) {
                            return;
                        }
                        d3.select(this)
                            .classed("link", 1)
                            .on('click', function (d) {
                                d.link(d.obj);
                                t.close.call(this);
                            });
                    });
            });
            return t;
        };

        tooltip.table = function () {
            // table tooltips are based on general tooltips
            var t = tooltip();

            var width = 180;

            t.fill (function (obj) {
                var tooltip_div = d3.select(this);

                var obj_info_table = tooltip_div
                    .append("table")
                    .attr("class", "tnt_zmenu")
                    .attr("border", "solid")
                    .style("width", t.width() + "px");

                // Tooltip header
                if (obj.header) {
                    obj_info_table
                        .append("tr")
                        .attr("class", "tnt_zmenu_header")
                        .append("th")
                        .attr("colspan", 2)
                        .text(obj.header);
                }

                // Tooltip rows
                var table_rows = obj_info_table.selectAll(".tnt_zmenu_row")
                    .data(obj.rows)
                    .enter()
                    .append("tr")
                    .attr("class", "tnt_zmenu_row");

                table_rows
                    .append("th")
                    .attr("colspan", function (d, i) {
                        if (d.value === "") {
                            return 2;
                        }
                        return 1;
                    })
                    .attr("class", function (d) {
                        if (d.value === "") {
                            return "tnt_zmenu_inner_header";
                        }
                        return "tnt_zmenu_cell";
                    })
                    .html(function(d,i) {
                        return obj.rows[i].label;
                    });

                table_rows
                    .append("td")
                    .html(function(d,i) {
                        if (typeof obj.rows[i].value === 'function') {
                            obj.rows[i].value.call(this, d);
                        } else {
                            return obj.rows[i].value;
                        }
                    })
                    .each(function (d) {
                        if (d.value === "") {
                            d3.select(this).remove();
                        }
                    })
                    .each(function (d) {
                        if (d.link === undefined) {
                            return;
                        }
                        d3.select(this)
                            .classed("link", 1)
                            .on('click', function (d) {
                                d.link(d.obj);
                                t.close.call(this);
                            });
                    });
            });

            return t;
        };

        tooltip.plain = function () {
            // plain tooltips are based on general tooltips
            var t = tooltip();

            t.fill (function (obj) {
                var tooltip_div = d3.select(this);

                var obj_info_table = tooltip_div
                    .append("table")
                    .attr("class", "tnt_zmenu")
                    .attr("border", "solid")
                    .style("width", t.width() + "px");

                if (obj.header) {
                    obj_info_table
                        .append("tr")
                        .attr("class", "tnt_zmenu_header")
                        .append("th")
                        .text(obj.header);
                }

                if (obj.body) {
                    obj_info_table
                        .append("tr")
                        .attr("class", "tnt_zmenu_row")
                        .append("td")
                        .style("text-align", "center")
                        .html(obj.body);
                }
            });

            return t;
        };

        module.exports = exports = tooltip;

    },{"tnt.api":3}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcSG9tZSBVc2VyXFxEb2N1bWVudHNcXHRudC50b29sdGlwXFxub2RlX21vZHVsZXNcXGJyb3dzZXItcGFja1xcX3ByZWx1ZGUuanMiLCJDOi9Vc2Vycy9Ib21lIFVzZXIvRG9jdW1lbnRzL3RudC50b29sdGlwL2Zha2VfNzM4YjkwYS5qcyIsIkM6L1VzZXJzL0hvbWUgVXNlci9Eb2N1bWVudHMvdG50LnRvb2x0aXAvaW5kZXguanMiLCJDOi9Vc2Vycy9Ib21lIFVzZXIvRG9jdW1lbnRzL3RudC50b29sdGlwL25vZGVfbW9kdWxlcy90bnQuYXBpL2luZGV4LmpzIiwiQzovVXNlcnMvSG9tZSBVc2VyL0RvY3VtZW50cy90bnQudG9vbHRpcC9ub2RlX21vZHVsZXMvdG50LmFwaS9zcmMvYXBpLmpzIiwiQzovVXNlcnMvSG9tZSBVc2VyL0RvY3VtZW50cy90bnQudG9vbHRpcC9zcmMvdG9vbHRpcC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiaWYgKHR5cGVvZiB0bnQgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gdG50ID0ge307XHJcbn1cclxudG50LnRvb2x0aXAgPSByZXF1aXJlKFwiLi9pbmRleC5qc1wiKTtcclxuIiwibW9kdWxlLmV4cG9ydHMgPSB0b29sdGlwID0gcmVxdWlyZShcIi4vc3JjL3Rvb2x0aXAuanNcIik7XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vc3JjL2FwaS5qc1wiKTtcbiIsInZhciBhcGkgPSBmdW5jdGlvbiAod2hvKSB7XG5cbiAgICB2YXIgX21ldGhvZHMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBtID0gW107XG5cblx0bS5hZGRfYmF0Y2ggPSBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICBtLnVuc2hpZnQob2JqKTtcblx0fTtcblxuXHRtLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXRob2QsIHZhbHVlKSB7XG5cdCAgICBmb3IgKHZhciBpPTA7IGk8bS5sZW5ndGg7IGkrKykge1xuXHRcdGZvciAodmFyIHAgaW4gbVtpXSkge1xuXHRcdCAgICBpZiAocCA9PT0gbWV0aG9kKSB7XG5cdFx0XHRtW2ldW3BdID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHQgICAgfVxuXHRcdH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBmYWxzZTtcblx0fTtcblxuXHRtLmFkZCA9IGZ1bmN0aW9uIChtZXRob2QsIHZhbHVlKSB7XG5cdCAgICBpZiAobS51cGRhdGUgKG1ldGhvZCwgdmFsdWUpICkge1xuXHQgICAgfSBlbHNlIHtcblx0XHR2YXIgcmVnID0ge307XG5cdFx0cmVnW21ldGhvZF0gPSB2YWx1ZTtcblx0XHRtLmFkZF9iYXRjaCAocmVnKTtcblx0ICAgIH1cblx0fTtcblxuXHRtLmdldCA9IGZ1bmN0aW9uIChtZXRob2QpIHtcblx0ICAgIGZvciAodmFyIGk9MDsgaTxtLmxlbmd0aDsgaSsrKSB7XG5cdFx0Zm9yICh2YXIgcCBpbiBtW2ldKSB7XG5cdFx0ICAgIGlmIChwID09PSBtZXRob2QpIHtcblx0XHRcdHJldHVybiBtW2ldW3BdO1xuXHRcdCAgICB9XG5cdFx0fVxuXHQgICAgfVxuXHR9O1xuXG5cdHJldHVybiBtO1xuICAgIH07XG5cbiAgICB2YXIgbWV0aG9kcyAgICA9IF9tZXRob2RzKCk7XG4gICAgdmFyIGFwaSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgYXBpLmNoZWNrID0gZnVuY3Rpb24gKG1ldGhvZCwgY2hlY2ssIG1zZykge1xuXHRpZiAobWV0aG9kIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0ICAgIGZvciAodmFyIGk9MDsgaTxtZXRob2QubGVuZ3RoOyBpKyspIHtcblx0XHRhcGkuY2hlY2sobWV0aG9kW2ldLCBjaGVjaywgbXNnKTtcblx0ICAgIH1cblx0ICAgIHJldHVybjtcblx0fVxuXG5cdGlmICh0eXBlb2YgKG1ldGhvZCkgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgIG1ldGhvZC5jaGVjayhjaGVjaywgbXNnKTtcblx0fSBlbHNlIHtcblx0ICAgIHdob1ttZXRob2RdLmNoZWNrKGNoZWNrLCBtc2cpO1xuXHR9XG5cdHJldHVybiBhcGk7XG4gICAgfTtcblxuICAgIGFwaS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAobWV0aG9kLCBjYmFrKSB7XG5cdGlmIChtZXRob2QgaW5zdGFuY2VvZiBBcnJheSkge1xuXHQgICAgZm9yICh2YXIgaT0wOyBpPG1ldGhvZC5sZW5ndGg7IGkrKykge1xuXHRcdGFwaS50cmFuc2Zvcm0gKG1ldGhvZFtpXSwgY2Jhayk7XG5cdCAgICB9XG5cdCAgICByZXR1cm47XG5cdH1cblxuXHRpZiAodHlwZW9mIChtZXRob2QpID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICBtZXRob2QudHJhbnNmb3JtIChjYmFrKTtcblx0fSBlbHNlIHtcblx0ICAgIHdob1ttZXRob2RdLnRyYW5zZm9ybShjYmFrKTtcblx0fVxuXHRyZXR1cm4gYXBpO1xuICAgIH07XG5cbiAgICB2YXIgYXR0YWNoX21ldGhvZCA9IGZ1bmN0aW9uIChtZXRob2QsIG9wdHMpIHtcblx0dmFyIGNoZWNrcyA9IFtdO1xuXHR2YXIgdHJhbnNmb3JtcyA9IFtdO1xuXG5cdHZhciBnZXR0ZXIgPSBvcHRzLm9uX2dldHRlciB8fCBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gbWV0aG9kcy5nZXQobWV0aG9kKTtcblx0fTtcblxuXHR2YXIgc2V0dGVyID0gb3B0cy5vbl9zZXR0ZXIgfHwgZnVuY3Rpb24gKHgpIHtcblx0ICAgIGZvciAodmFyIGk9MDsgaTx0cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG5cdFx0eCA9IHRyYW5zZm9ybXNbaV0oeCk7XG5cdCAgICB9XG5cblx0ICAgIGZvciAodmFyIGo9MDsgajxjaGVja3MubGVuZ3RoOyBqKyspIHtcblx0XHRpZiAoIWNoZWNrc1tqXS5jaGVjayh4KSkge1xuXHRcdCAgICB2YXIgbXNnID0gY2hlY2tzW2pdLm1zZyB8fCBcblx0XHRcdChcIlZhbHVlIFwiICsgeCArIFwiIGRvZXNuJ3Qgc2VlbSB0byBiZSB2YWxpZCBmb3IgdGhpcyBtZXRob2RcIik7XG5cdFx0ICAgIHRocm93IChtc2cpO1xuXHRcdH1cblx0ICAgIH1cblx0ICAgIG1ldGhvZHMuYWRkKG1ldGhvZCwgeCk7XG5cdH07XG5cblx0dmFyIG5ld19tZXRob2QgPSBmdW5jdGlvbiAobmV3X3ZhbCkge1xuXHQgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0cmV0dXJuIGdldHRlcigpO1xuXHQgICAgfVxuXHQgICAgc2V0dGVyKG5ld192YWwpO1xuXHQgICAgcmV0dXJuIHdobzsgLy8gUmV0dXJuIHRoaXM/XG5cdH07XG5cdG5ld19tZXRob2QuY2hlY2sgPSBmdW5jdGlvbiAoY2JhaywgbXNnKSB7XG5cdCAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRyZXR1cm4gY2hlY2tzO1xuXHQgICAgfVxuXHQgICAgY2hlY2tzLnB1c2ggKHtjaGVjayA6IGNiYWssXG5cdFx0XHQgIG1zZyAgIDogbXNnfSk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0fTtcblx0bmV3X21ldGhvZC50cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2Jhaykge1xuXHQgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0cmV0dXJuIHRyYW5zZm9ybXM7XG5cdCAgICB9XG5cdCAgICB0cmFuc2Zvcm1zLnB1c2goY2Jhayk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0fTtcblxuXHR3aG9bbWV0aG9kXSA9IG5ld19tZXRob2Q7XG4gICAgfTtcblxuICAgIHZhciBnZXRzZXQgPSBmdW5jdGlvbiAocGFyYW0sIG9wdHMpIHtcblx0aWYgKHR5cGVvZiAocGFyYW0pID09PSAnb2JqZWN0Jykge1xuXHQgICAgbWV0aG9kcy5hZGRfYmF0Y2ggKHBhcmFtKTtcblx0ICAgIGZvciAodmFyIHAgaW4gcGFyYW0pIHtcblx0XHRhdHRhY2hfbWV0aG9kIChwLCBvcHRzKTtcblx0ICAgIH1cblx0fSBlbHNlIHtcblx0ICAgIG1ldGhvZHMuYWRkIChwYXJhbSwgb3B0cy5kZWZhdWx0X3ZhbHVlKTtcblx0ICAgIGF0dGFjaF9tZXRob2QgKHBhcmFtLCBvcHRzKTtcblx0fVxuICAgIH07XG5cbiAgICBhcGkuZ2V0c2V0ID0gZnVuY3Rpb24gKHBhcmFtLCBkZWYpIHtcblx0Z2V0c2V0KHBhcmFtLCB7ZGVmYXVsdF92YWx1ZSA6IGRlZn0pO1xuXG5cdHJldHVybiBhcGk7XG4gICAgfTtcblxuICAgIGFwaS5nZXQgPSBmdW5jdGlvbiAocGFyYW0sIGRlZikge1xuXHR2YXIgb25fc2V0dGVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgdGhyb3cgKFwiTWV0aG9kIGRlZmluZWQgb25seSBhcyBhIGdldHRlciAoeW91IGFyZSB0cnlpbmcgdG8gdXNlIGl0IGFzIGEgc2V0dGVyXCIpO1xuXHR9O1xuXG5cdGdldHNldChwYXJhbSwge2RlZmF1bHRfdmFsdWUgOiBkZWYsXG5cdFx0ICAgICAgIG9uX3NldHRlciA6IG9uX3NldHRlcn1cblx0ICAgICAgKTtcblxuXHRyZXR1cm4gYXBpO1xuICAgIH07XG5cbiAgICBhcGkuc2V0ID0gZnVuY3Rpb24gKHBhcmFtLCBkZWYpIHtcblx0dmFyIG9uX2dldHRlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRocm93IChcIk1ldGhvZCBkZWZpbmVkIG9ubHkgYXMgYSBzZXR0ZXIgKHlvdSBhcmUgdHJ5aW5nIHRvIHVzZSBpdCBhcyBhIGdldHRlclwiKTtcblx0fTtcblxuXHRnZXRzZXQocGFyYW0sIHtkZWZhdWx0X3ZhbHVlIDogZGVmLFxuXHRcdCAgICAgICBvbl9nZXR0ZXIgOiBvbl9nZXR0ZXJ9XG5cdCAgICAgICk7XG5cblx0cmV0dXJuIGFwaTtcbiAgICB9O1xuXG4gICAgYXBpLm1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lLCBjYmFrKSB7XG5cdGlmICh0eXBlb2YgKG5hbWUpID09PSAnb2JqZWN0Jykge1xuXHQgICAgZm9yICh2YXIgcCBpbiBuYW1lKSB7XG5cdFx0d2hvW3BdID0gbmFtZVtwXTtcblx0ICAgIH1cblx0fSBlbHNlIHtcblx0ICAgIHdob1tuYW1lXSA9IGNiYWs7XG5cdH1cblx0cmV0dXJuIGFwaTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGFwaTtcbiAgICBcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGFwaTsiLCJ2YXIgYXBpanMgPSByZXF1aXJlKFwidG50LmFwaVwiKTtcclxuXHJcbnZhciB0b29sdGlwID0gZnVuY3Rpb24gKCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgdmFyIGRyYWcgPSBkMy5kcmFnKCk7XHJcbiAgICB2YXIgdG9vbHRpcF9kaXY7XHJcblxyXG4gICAgdmFyIGNvbmYgPSB7XHJcbiAgICAgICAgY29udGFpbmVyOiB1bmRlZmluZWQsXHJcbiAgICAgICAgcG9zaXRpb24gOiBcInJpZ2h0XCIsXHJcbiAgICAgICAgYWxsb3dfZHJhZyA6IHRydWUsXHJcbiAgICAgICAgc2hvd19jbG9zZXIgOiBmYWxzZSxcclxuICAgICAgICBmaWxsIDogZnVuY3Rpb24gKCkgeyB0aHJvdyBcImZpbGwgaXMgbm90IGRlZmluZWQgaW4gdGhlIGJhc2Ugb2JqZWN0XCI7IH0sXHJcbiAgICAgICAgd2lkdGggOiAxODAsXHJcbiAgICAgICAgaWQgOiAxXHJcbiAgICB9O1xyXG5cclxuICAgIHZhciB0ID0gZnVuY3Rpb24gKGRhdGEsIGV2ZW50KSB7XHJcbiAgICAgICAgZHJhZ1xyXG4gICAgICAgICAgICAuc3ViamVjdChmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB4IDogcGFyc2VJbnQoZDMuc2VsZWN0KHRoaXMpLnN0eWxlKFwibGVmdFwiKSksXHJcbiAgICAgICAgICAgICAgICAgICAgeSA6IHBhcnNlSW50KGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcInRvcFwiKSlcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5vbihcImRyYWdcIiwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29uZi5hbGxvd19kcmFnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImxlZnRcIiwgZDMuZXZlbnQueCArIFwicHhcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwidG9wXCIsIGQzLmV2ZW50LnkgKyBcInB4XCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gVE9ETzogV2h5IGRvIHdlIG5lZWQgdGhlIGRpdiBlbGVtZW50P1xyXG4gICAgICAgIC8vIEl0IGxvb2tzIGxpa2UgaWYgd2UgYW5jaG9yIHRoZSB0b29sdGlwIGluIHRoZSBcImJvZHlcIlxyXG4gICAgICAgIC8vIFRoZSB0b29sdGlwIGlzIG5vdCBsb2NhdGVkIGluIHRoZSByaWdodCBwbGFjZSAoYXBwZWFycyBhdCB0aGUgYm90dG9tKVxyXG4gICAgICAgIC8vIFNlZSBjbGllbnRzL3Rvb2x0aXBzX3Rlc3QuaHRtbCBmb3IgYW4gZXhhbXBsZVxyXG4gICAgICAgIHZhciBjb250YWluZXJFbGVtID0gY29uZi5jb250YWluZXI7XHJcbiAgICAgICAgaWYgKCFjb250YWluZXJFbGVtKSB7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lckVsZW0gPSBzZWxlY3RBbmNlc3Rvcih0aGlzLCBcImRpdlwiKTtcclxuICAgICAgICAgICAgaWYgKGNvbnRhaW5lckVsZW0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgcmVxdWlyZSBhIGRpdiBlbGVtZW50IGF0IHNvbWUgcG9pbnQgdG8gYW5jaG9yIHRoZSB0b29sdGlwXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRvb2x0aXBfZGl2ID0gZDMuc2VsZWN0KGNvbnRhaW5lckVsZW0pXHJcbiAgICAgICAgICAgIC5hcHBlbmQoXCJkaXZcIilcclxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInRudF90b29sdGlwXCIpXHJcbiAgICAgICAgICAgIC5jbGFzc2VkKFwidG50X3Rvb2x0aXBfYWN0aXZlXCIsIHRydWUpICAvLyBUT0RPOiBJcyB0aGlzIG5lZWRlZC91c2VkPz8/XHJcbiAgICAgICAgICAgIC5jYWxsKGRyYWcpO1xyXG5cclxuICAgICAgICAvLyBwcmV2IHRvb2x0aXBzIHdpdGggdGhlIHNhbWUgaGVhZGVyXHJcbiAgICAgICAgZDMuc2VsZWN0KFwiI3RudF90b29sdGlwX1wiICsgY29uZi5pZCkucmVtb3ZlKCk7XHJcblxyXG4gICAgICAgIGlmICgoZDMuZXZlbnQgPT09IG51bGwpICYmIChldmVudCkpIHtcclxuICAgICAgICAgICAgZDMuZXZlbnQgPSBldmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGQzbW91c2UgPSBkMy5tb3VzZShjb250YWluZXJFbGVtKTtcclxuICAgICAgICBkMy5ldmVudCA9IG51bGw7XHJcblxyXG4gICAgICAgIHZhciB4b2Zmc2V0ID0gMTA7XHJcblx0XHR2YXIgeW9mZnNldCA9IDEwO1xyXG4gICAgICAgIGlmIChjb25mLnBvc2l0aW9uID09PSBcImxlZnRcIikge1xyXG4gICAgICAgICAgICB4b2Zmc2V0ID0gY29uZi53aWR0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRvb2x0aXBfZGl2LmF0dHIoXCJpZFwiLCBcInRudF90b29sdGlwX1wiICsgY29uZi5pZCk7XHJcblxyXG4gICAgICAgIC8vIFdlIHBsYWNlIHRoZSB0b29sdGlwXHJcbiAgICAgICAgdG9vbHRpcF9kaXZcclxuICAgICAgICAgICAgLnN0eWxlKFwibGVmdFwiLCAoZDNtb3VzZVswXSAtIHhvZmZzZXQpICsgXCJweFwiKVxyXG4gICAgICAgICAgICAuc3R5bGUoXCJ0b3BcIiwgKGQzbW91c2VbMV0gLSB5b2Zmc2V0KSArIFwicHhcIik7XHJcblxyXG4gICAgICAgIC8vIENsb3NlXHJcbiAgICAgICAgaWYgKGNvbmYuc2hvd19jbG9zZXIpIHtcclxuICAgICAgICAgICAgdG9vbHRpcF9kaXZcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJkaXZcIilcclxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ0bnRfdG9vbHRpcF9jbG9zZXJcIilcclxuICAgICAgICAgICAgICAgIC5vbiAoXCJjbGlja1wiLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdC5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25mLmZpbGwuY2FsbCh0b29sdGlwX2Rpdi5ub2RlKCksIGRhdGEpO1xyXG5cclxuICAgICAgICAvLyByZXR1cm4gdGhpcyBoZXJlP1xyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBnZXRzIHRoZSBmaXJzdCBhbmNlc3RvciBvZiBlbGVtIGhhdmluZyB0YWduYW1lIFwidHlwZVwiXHJcbiAgICAvLyBleGFtcGxlIDogdmFyIG15ZGl2ID0gc2VsZWN0QW5jZXN0b3IobXllbGVtLCBcImRpdlwiKTtcclxuICAgIGZ1bmN0aW9uIHNlbGVjdEFuY2VzdG9yIChlbGVtLCB0eXBlKSB7XHJcbiAgICAgICAgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBpZiAoZWxlbS5wYXJlbnROb2RlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm8gbW9yZSBwYXJlbnRzXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdGFnTmFtZSA9IGVsZW0ucGFyZW50Tm9kZS50YWdOYW1lO1xyXG5cclxuICAgICAgICBpZiAoKHRhZ05hbWUgIT09IHVuZGVmaW5lZCkgJiYgKHRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gdHlwZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVsZW0ucGFyZW50Tm9kZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0QW5jZXN0b3IgKGVsZW0ucGFyZW50Tm9kZSwgdHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBhcGkgPSBhcGlqcyh0KVxyXG4gICAgICAgIC5nZXRzZXQoY29uZik7XHJcblxyXG4gICAgYXBpLmNoZWNrKCdwb3NpdGlvbicsIGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICByZXR1cm4gKHZhbCA9PT0gJ2xlZnQnKSB8fCAodmFsID09PSAncmlnaHQnKTtcclxuICAgIH0sIFwiT25seSAnbGVmdCcgb3IgJ3JpZ2h0JyB2YWx1ZXMgYXJlIGFsbG93ZWQgZm9yIHBvc2l0aW9uXCIpO1xyXG5cclxuICAgIGFwaS5tZXRob2QoJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0b29sdGlwX2Rpdikge1xyXG4gICAgICAgICAgICB0b29sdGlwX2Rpdi5yZW1vdmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gdDtcclxufTtcclxuXHJcbnRvb2x0aXAubGlzdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIGxpc3QgdG9vbHRpcCBpcyBiYXNlZCBvbiBnZW5lcmFsIHRvb2x0aXBzXHJcbiAgICB2YXIgdCA9IHRvb2x0aXAoKTtcclxuICAgIHZhciB3aWR0aCA9IDE4MDtcclxuXHJcbiAgICB0LmZpbGwgKGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICB2YXIgdG9vbHRpcF9kaXYgPSBkMy5zZWxlY3QodGhpcyk7XHJcbiAgICAgICAgdmFyIG9ial9pbmZvX2xpc3QgPSB0b29sdGlwX2RpdlxyXG4gICAgICAgICAgICAuYXBwZW5kKFwidGFibGVcIilcclxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInRudF96bWVudVwiKVxyXG4gICAgICAgICAgICAuYXR0cihcImJvcmRlclwiLCBcInNvbGlkXCIpXHJcbiAgICAgICAgICAgIC5zdHlsZShcIndpZHRoXCIsIHQud2lkdGgoKSArIFwicHhcIik7XHJcblxyXG4gICAgICAgIC8vIFRvb2x0aXAgaGVhZGVyXHJcbiAgICAgICAgaWYgKG9iai5oZWFkZXIpIHtcclxuICAgICAgICAgICAgb2JqX2luZm9fbGlzdFxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcInRyXCIpXHJcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwidG50X3ptZW51X2hlYWRlclwiKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcInRoXCIpXHJcbiAgICAgICAgICAgICAgICAudGV4dChvYmouaGVhZGVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRvb2x0aXAgcm93c1xyXG4gICAgICAgIHZhciB0YWJsZV9yb3dzID0gb2JqX2luZm9fbGlzdC5zZWxlY3RBbGwoXCIudG50X3ptZW51X3Jvd1wiKVxyXG4gICAgICAgICAgICAuZGF0YShvYmoucm93cylcclxuICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgLmFwcGVuZChcInRyXCIpXHJcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ0bnRfem1lbnVfcm93XCIpO1xyXG5cclxuICAgICAgICB0YWJsZV9yb3dzXHJcbiAgICAgICAgICAgIC5hcHBlbmQoXCJ0ZFwiKVxyXG4gICAgICAgICAgICAuc3R5bGUoXCJ0ZXh0LWFsaWduXCIsIFwiY2VudGVyXCIpXHJcbiAgICAgICAgICAgIC5odG1sKGZ1bmN0aW9uKGQsaSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iai5yb3dzW2ldLnZhbHVlO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuZWFjaChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGQubGluayA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICAgICAgLmNsYXNzZWQoXCJsaW5rXCIsIDEpXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQubGluayhkLm9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQuY2xvc2UuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0O1xyXG59O1xyXG5cclxudG9vbHRpcC50YWJsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIHRhYmxlIHRvb2x0aXBzIGFyZSBiYXNlZCBvbiBnZW5lcmFsIHRvb2x0aXBzXHJcbiAgICB2YXIgdCA9IHRvb2x0aXAoKTtcclxuXHJcbiAgICB2YXIgd2lkdGggPSAxODA7XHJcblxyXG4gICAgdC5maWxsIChmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgdmFyIHRvb2x0aXBfZGl2ID0gZDMuc2VsZWN0KHRoaXMpO1xyXG5cclxuICAgICAgICB2YXIgb2JqX2luZm9fdGFibGUgPSB0b29sdGlwX2RpdlxyXG4gICAgICAgICAgICAuYXBwZW5kKFwidGFibGVcIilcclxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInRudF96bWVudVwiKVxyXG4gICAgICAgICAgICAuYXR0cihcImJvcmRlclwiLCBcInNvbGlkXCIpXHJcbiAgICAgICAgICAgIC5zdHlsZShcIndpZHRoXCIsIHQud2lkdGgoKSArIFwicHhcIik7XHJcblxyXG4gICAgICAgIC8vIFRvb2x0aXAgaGVhZGVyXHJcbiAgICAgICAgaWYgKG9iai5oZWFkZXIpIHtcclxuICAgICAgICAgICAgb2JqX2luZm9fdGFibGVcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJ0clwiKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInRudF96bWVudV9oZWFkZXJcIilcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJ0aFwiKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjb2xzcGFuXCIsIDIpXHJcbiAgICAgICAgICAgICAgICAudGV4dChvYmouaGVhZGVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRvb2x0aXAgcm93c1xyXG4gICAgICAgIHZhciB0YWJsZV9yb3dzID0gb2JqX2luZm9fdGFibGUuc2VsZWN0QWxsKFwiLnRudF96bWVudV9yb3dcIilcclxuICAgICAgICAgICAgLmRhdGEob2JqLnJvd3MpXHJcbiAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoXCJ0clwiKVxyXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwidG50X3ptZW51X3Jvd1wiKTtcclxuXHJcbiAgICAgICAgdGFibGVfcm93c1xyXG4gICAgICAgICAgICAuYXBwZW5kKFwidGhcIilcclxuICAgICAgICAgICAgLmF0dHIoXCJjb2xzcGFuXCIsIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZC52YWx1ZSA9PT0gXCJcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkLnZhbHVlID09PSBcIlwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidG50X3ptZW51X2lubmVyX2hlYWRlclwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwidG50X3ptZW51X2NlbGxcIjtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmh0bWwoZnVuY3Rpb24oZCxpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqLnJvd3NbaV0ubGFiZWw7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0YWJsZV9yb3dzXHJcbiAgICAgICAgICAgIC5hcHBlbmQoXCJ0ZFwiKVxyXG4gICAgICAgICAgICAuaHRtbChmdW5jdGlvbihkLGkpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqLnJvd3NbaV0udmFsdWUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBvYmoucm93c1tpXS52YWx1ZS5jYWxsKHRoaXMsIGQpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqLnJvd3NbaV0udmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZC52YWx1ZSA9PT0gXCJcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmVhY2goZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkLmxpbmsgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgLmNsYXNzZWQoXCJsaW5rXCIsIDEpXHJcbiAgICAgICAgICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgICAgICBkLmxpbmsoZC5vYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIHQuY2xvc2UuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0O1xyXG59O1xyXG5cclxudG9vbHRpcC5wbGFpbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIHBsYWluIHRvb2x0aXBzIGFyZSBiYXNlZCBvbiBnZW5lcmFsIHRvb2x0aXBzXHJcbiAgICB2YXIgdCA9IHRvb2x0aXAoKTtcclxuXHJcbiAgICB0LmZpbGwgKGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICB2YXIgdG9vbHRpcF9kaXYgPSBkMy5zZWxlY3QodGhpcyk7XHJcblxyXG4gICAgICAgIHZhciBvYmpfaW5mb190YWJsZSA9IHRvb2x0aXBfZGl2XHJcbiAgICAgICAgICAgIC5hcHBlbmQoXCJ0YWJsZVwiKVxyXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwidG50X3ptZW51XCIpXHJcbiAgICAgICAgICAgIC5hdHRyKFwiYm9yZGVyXCIsIFwic29saWRcIilcclxuICAgICAgICAgICAgLnN0eWxlKFwid2lkdGhcIiwgdC53aWR0aCgpICsgXCJweFwiKTtcclxuXHJcbiAgICAgICAgaWYgKG9iai5oZWFkZXIpIHtcclxuICAgICAgICAgICAgb2JqX2luZm9fdGFibGVcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJ0clwiKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInRudF96bWVudV9oZWFkZXJcIilcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJ0aFwiKVxyXG4gICAgICAgICAgICAgICAgLnRleHQob2JqLmhlYWRlcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob2JqLmJvZHkpIHtcclxuICAgICAgICAgICAgb2JqX2luZm9fdGFibGVcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJ0clwiKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInRudF96bWVudV9yb3dcIilcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJ0ZFwiKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwidGV4dC1hbGlnblwiLCBcImNlbnRlclwiKVxyXG4gICAgICAgICAgICAgICAgLmh0bWwob2JqLmJvZHkpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gdG9vbHRpcDtcclxuIl19
